import streamlit as st
import re
import string
import numpy as np
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
import nltk
from nltk.corpus import stopwords
from nltk.stem import WordNetLemmatizer
from sklearn.metrics.pairwise import cosine_similarity
import json
from datetime import datetime

# --- Estiliza√ß√£o G√≥tica e Rock'n'Roll ---
# NOTA: A inje√ß√£o de CSS com unsafe_allow_html √© um recurso poderoso, mas deve ser usado com cuidado.
st.markdown("""
    <style>
        /* Importa uma fonte g√≥tica do Google Fonts */
        @import url('https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap');

        /* Fundo preto com estrelas brancas */
        .stApp {
            background-color: #000000;
            background-image:
                radial-gradient(white, rgba(255,255,255,.2) 2px, transparent 40px),
                radial-gradient(white, rgba(255,255,255,.15) 1px, transparent 30px),
                radial-gradient(white, rgba(255,255,255,.1) 2px, transparent 40px),
                radial-gradient(rgba(255,255,255,.4), rgba(255,255,255,.1) 2px, transparent 30px);
            background-size: 550px 550px, 350px 350px, 250px 250px, 150px 150px;
            background-position: 0 0, 40px 60px, 130px 270px, 70px 100px;
            color: #FFFFFF;
        }

        /* T√≠tulo Principal */
        .rockstar-title {
            font-family: 'MedievalSharp', cursive;
            font-size: 4.5em;
            color: #E50000; /* Vermelho Sangue */
            font-weight: bold;
            text-align: center;
            text-shadow: 2px 2px 4px #000000;
            margin-bottom: 0.2em;
        }
        
        /* Personalizar bot√£o primary para cor roxa escura */
        .stButton > button[kind="primary"] {
            background-color: #4B0082 !important; /* Roxo Indigo */
            border: 2px solid #E50000 !important;
            color: white !important;
            font-weight: bold;
        }
        
        .stButton > button[kind="primary"]:hover {
            background-color: #8B008B !important; /* Magenta Escuro */
            border-color: #FF4500 !important;
        }
        
        /* Container das respostas do chatbot */
        .chatbot-response {
            background-color: #1a1a1a;
            color: #ffffff;
            padding: 15px;
            border-radius: 10px;
            border-left: 5px solid #E50000;
            margin: 10px 0;
            word-wrap: break-word;
        }
        
        /* Muda a cor dos cabe√ßalhos (h1, h2, h3) */
        h1, h2, h3 {
            color: #E50000 !important;
        }
        
        /* Muda a cor do texto do slider */
        .stSlider [data-baseweb="slider"] {
             color: #FFFFFF !important;
        }

    </style>
    <div class="rockstar-title">RockStar Burger</div>
""", unsafe_allow_html=True)
# --- Fim do bloco visual ---

# Dataset tem√°tico de intents para RockStar Burger
intents = {
    "greeting": {
        "examples": [
            "e a√≠", "fala", "hey", "hello", "oi", "ol√°", "bom dia", "boa tarde", "boa noite",
            "salve", "eae", "oi boa tarde", "ola", "cumprimentando voc√™s", "oii", "oie",
            "fla", "flw", "eai", "oi pessoal", "oiii", "opa", "opaaa", "salveee",
            "heey", "helo", "hellooo", "bom diaa", "boaa tarde", "boaaa noite"
        ],
        "responses": [
            "E a√≠, rockstar! ü§ò Bem-vindo ao RockStar Burger! Pronto pra detonar na fome?",
            "Fala, lenda! üíÄ Chega mais, a casa do rock t√° aberta. O que voc√™ manda hoje?",
            "Salve! Bem-vindo ao nosso palco. Qual o seu pedido pra come√ßar o show?",
            "Hey! Que a for√ßa do metal esteja com voc√™! Como posso te ajudar?"
        ]
    },
    
    "goodbye": {
        "examples": [
            "falou", "adeus", "bye", "flw", "tchau", "at√© mais", "at√© logo",
            "valeu tchau", "xau", "obrigado tchau", "nos vemos", "falow", "adeos",
            "bai", "baye", "tiau", "tchauu", "at√© maiss", "ate mais", "xauu",
            "obrigado tchao", "nos vemoss", "fui", "fuii", "to indo", "vou indo"
        ],
        "responses": [
            "Falou! Keep on rockin' e volte sempre! ü§ò",
            "At√© a pr√≥xima! Obrigado por escolher o RockStar Burger!",
            "Valeu, rockstar! A gente se v√™ no pr√≥ximo show!",
            "Tchau! Foi um prazer atender uma lenda como voc√™!"
        ]
    },
    
    "thanks": {
        "examples": [
            "valeu", "brigado", "mt obrigado", "obrigada", "muito grato", "grato", "agradeco",
            "obrigado", "muito obrigado", "vlw", "agradecido", "thanks", "valeuu", "brigadu",
            "mt obrigadu", "obrigadaa", "muito gratu", "gratu", "agradeso", "obrigadu",
            "mto obrigado", "valw", "agradecidu", "tankss", "thank you", "grato demais"
        ],
        "responses": [
            "√â n√≥is! ü§ò Tamo junto sempre que precisar.",
            "De nada! O rock agradece a sua presen√ßa!",
            "Disponha! √â pra isso que estamos aqui!",
            "Tranquilo! Precisando, √© s√≥ chamar no palco!"
        ]
    },
    
    "purchase": {
        "examples": [
            "quero pedir", "posso fazer um pedido?", "quero um burger", "me v√™ um hamb√∫rguer",
            "quero comprar um hamb√∫rguer", "gostaria de fazer um pedido", "quero comprar",
            "t√¥ com fome", "to com fome", "pedir comida", "kero pedir", "posso faser um pedido?",
            "kero um burger", "me ve um hamburger", "quero compra um hamburger", "gostaria de faser um pedido",
            "kero comprar", "to com fomi", "tou com fome", "pedi comida", "fazer pedido", "vou pedir"
        ],
        "responses": [
            "Show! Nossos hits s√£o de peso! Se liga no setlist:\n‚Ä¢ **Master of Burgers (Metallica)** - R$ 35\n‚Ä¢ **Appetite for Destruction (Guns N' Roses)** - R$ 38\n‚Ä¢ **Highway to Hell (AC/DC)** - R$ 33\n‚Ä¢ **Ace of Spades (Mot√∂rhead)** - Vegano - R$ 32\n\nQual vai ser a pedida?",
            "Volume no m√°ximo! üé∏ Nossos cl√°ssicos incluem:\n‚Ä¢ **The Trooper (Iron Maiden)** - R$ 36\n‚Ä¢ **Paranoid (Black Sabbath)** - R$ 34\n‚Ä¢ **Stairway to Heaven (Led Zeppelin)** - R$ 40\n\nQual desses hinos vai matar sua fome?",
            "Bora pro rock! ü§ò Temos essas op√ß√µes devastadoras:\n‚Ä¢ **Master of Burgers** - O cl√°ssico do Metallica - R$ 35\n‚Ä¢ **Highway to Hell** - Levemente apimentado - R$ 33\n‚Ä¢ **Stairway to Heaven** - Nosso burger lend√°rio - R$ 40\n\nO que voc√™ escolhe?",
            "Prepara o palco! üé∏ Nossos sucessos incluem:\n‚Ä¢ **Appetite for Destruction** - Explosivo como o Guns - R$ 38\n‚Ä¢ **The Trooper** - Batalha √©pica do Iron Maiden - R$ 36\n‚Ä¢ **Ace of Spades** - Op√ß√£o vegana do Mot√∂rhead - R$ 32\n\nQual vai ser?"
        ]
    },
    
    "menu": {
        "examples": [
            "que hamb√∫rgueres voc√™s t√™m", "quais os lanches dispon√≠veis", "mostrem o menu",
            "qual o card√°pio", "o que voc√™s vendem", "cardapio completo",
            "lista de hamburguer", "ver menu", "que lanches tem", "ke hamburgueres voces tem",
            "kais os lanches disponiveis", "mostrem o meno", "kual o cardapio", "o ke voces vendem",
            "cardapiu completo", "lista de hamburger", "ve menu", "ke lanches tem", "opcoes de lanche",
            "menu completo", "card√°pio de hoje", "o que tem no card√°pio", "ver op√ß√µes"
        ],
        "responses": [
            "Aqui est√° o nosso setlist completo! ü§ò\n\n**HITS DO METAL:**\n‚Ä¢ **Master of Burgers (Metallica)** - R$ 35\n‚Ä¢ **Appetite for Destruction (Guns N' Roses)** - R$ 38\n‚Ä¢ **The Trooper (Iron Maiden)** - R$ 36\n\n**CL√ÅSSICOS DO ROCK:**\n‚Ä¢ **Highway to Hell (AC/DC)** - R$ 33 (levemente apimentado! üî•)\n‚Ä¢ **Paranoid (Black Sabbath)** - R$ 34\n‚Ä¢ **Stairway to Heaven (Led Zeppelin)** - R$ 40\n\n**OP√á√ÉO VEGANA:**\n‚Ä¢ **Ace of Spades (Mot√∂rhead)** - R$ 32\n\nTemos tamb√©m acompanhamentos e bebidas pra completar o show!",
            "Bora conhecer nosso arsenal! üé∏\n\n**OS PESADOS:**\n‚Ä¢ Master of Burgers - O poder do Metallica - R$ 35\n‚Ä¢ Appetite for Destruction - Explos√£o Guns N' Roses - R$ 38\n‚Ä¢ The Trooper - Batalha Iron Maiden - R$ 36\n\n**OS CL√ÅSSICOS:**\n‚Ä¢ Highway to Hell - Com fogo AC/DC - R$ 33\n‚Ä¢ Paranoid - Loucura Black Sabbath - R$ 34\n‚Ä¢ Stairway to Heaven - Lenda Led Zeppelin - R$ 40\n\n**VEGANO ROCK:**\n‚Ä¢ Ace of Spades - Mot√∂rhead verde - R$ 32",
            "Nosso card√°pio √© puro rock! ü§ò\n\n‚Ä¢ **Master of Burgers** (Metallica) - R$ 35\n‚Ä¢ **Appetite for Destruction** (Guns N' Roses) - R$ 38\n‚Ä¢ **The Trooper** (Iron Maiden) - R$ 36\n‚Ä¢ **Highway to Hell** (AC/DC) - R$ 33\n‚Ä¢ **Paranoid** (Black Sabbath) - R$ 34\n‚Ä¢ **Stairway to Heaven** (Led Zeppelin) - R$ 40\n‚Ä¢ **Ace of Spades** (Mot√∂rhead - Vegano) - R$ 32\n\nTodos feitos com ingredientes de primeira!",
            "Se liga na nossa discografia gastron√¥mica! üéµ\n\n**METAL SUPREMO:** Master of Burgers (R$ 35), Appetite for Destruction (R$ 38), The Trooper (R$ 36)\n\n**ROCK CL√ÅSSICO:** Highway to Hell (R$ 33), Paranoid (R$ 34), Stairway to Heaven (R$ 40)\n\n**ALTERNATIVO:** Ace of Spades Vegano (R$ 32)\n\nQual vai ser sua escolha?"
        ]
    },
    
    "prices": {
        "examples": [
            "valores dos hamb√∫rgueres", "pre√ßo do burger", "quanto √© o hamb√∫rguer", "valor do lanche",
            "quanto custa", "qual o pre√ßo", "precos", "custa quanto", "valor do Master of Burgers",
            "valores dos hamburgueres", "preco do burger", "kuanto e o hamburguer", "valor do lanchi",
            "kuanto kusta", "kual o preco", "prekos", "kusta kuanto", "valor do Master of Burgers",
            "pre√ßo dos lanches", "quanto custa cada um", "tabela de pre√ßos", "valores", "pre√ßos dos burgers",
            "quanto sai", "valor de cada", "pre√ßo individual"
        ],
        "responses": [
            "Se liga na tabela de pre√ßos dos nossos hits:\n‚Ä¢ **Master of Burgers**: R$ 35\n‚Ä¢ **Appetite for Destruction**: R$ 38\n‚Ä¢ **The Trooper**: R$ 36\n‚Ä¢ **Highway to Hell**: R$ 33\n‚Ä¢ **Paranoid**: R$ 34\n‚Ä¢ **Stairway to Heaven**: R$ 40\n‚Ä¢ **Ace of Spades (Vegano)**: R$ 32",
            "Valores pra detonar na fome:\n‚Ä¢ **Cl√°ssicos (R$ 32-34)**: Ace of Spades, Highway to Hell, Paranoid.\n‚Ä¢ **Hinos do Metal (R$ 35-38)**: Master of Burgers, The Trooper, Appetite for Destruction.\n‚Ä¢ **Lend√°rio (R$ 40)**: Stairway to Heaven, nosso burger mais √©pico!",
            "Nossos pre√ßos s√£o justos como um bom riff! üé∏\n\nDo mais em conta ao premium:\nR$ 32 - Ace of Spades (Vegano)\nR$ 33 - Highway to Hell\nR$ 34 - Paranoid\nR$ 35 - Master of Burgers\nR$ 36 - The Trooper\nR$ 38 - Appetite for Destruction\nR$ 40 - Stairway to Heaven",
            "Aqui est√° a nossa tabela rock! ü§ò\n\nüí∞ **ENTRADA VIP (R$ 32-34):** Ace of Spades, Highway to Hell, Paranoid\nüí∞ **PISTA (R$ 35-36):** Master of Burgers, The Trooper\nüí∞ **CAMAROTE (R$ 38-40):** Appetite for Destruction, Stairway to Heaven"
        ]
    },
    
    "delivery_time": {
        "examples": [
            "tempo de entrega", "demora quanto", "quando fica pronto", "quanto tempo para entregar",
            "demora pra chegar", "quanto tempo demora", "prazo de entrega", "quando vai chegar",
            "tempo de intrega", "dimora quanto", "kuando fica pronto", "kuanto tempo para entregar",
            "dimora pra chegar", "kuanto tempo dimora", "praso de entrega", "kuando vai chegar",
            "demora muito", "leva quanto tempo", "em quanto tempo fica pronto", "prazo",
            "tempo pra ficar pronto", "delivery demora", "entrega r√°pida", "quanto tempo leva"
        ],
        "responses": [
            "Nossa cozinha √© r√°pida como um solo de guitarra! üé∏ O preparo leva de 15-20 minutos. Para delivery, some mais uns 20-30 minutos, dependendo de onde for o seu show.",
            "Sem demora! Seu lanche fica pronto em uns 20 minutos aqui na casa. Se for pra levar, o tempo total √© de uns 40-50 minutos pra chegar voando at√© voc√™.",
            "Velocidade do rock! ü§ò Preparo: 15-20 min. Delivery: + 20-30 min (varia pela dist√¢ncia). Total m√°ximo: uns 50 minutos para o show chegar na sua casa!",
            "R√°pido como uma batida dupla! ü•Å 15-20 min na cozinha + 20-30 min de entrega. Voc√™ vai estar saboreando nosso rock em menos de 1 hora!"
        ]
    },
    
    "complaint": {
        "examples": [
            "hamb√∫rguer veio frio", "pedido errado", "demora muito", "atendimento ruim",
            "quero reclamar", "n√£o gostei", "reclamacao", "problema com pedido", "insatisfeito",
            "hamburguer veio friu", "pedidu errado", "dimora muito", "atendimento ruim",
            "kero reclamar", "nao gostei", "reclamacau", "problema com pedidu", "insatisfeitu",
            "comida fria", "pedido atrasado", "erro no pedido", "ruim", "horrivel",
            "demorou demais", "qualidade ruim", "n√£o recomendo", "decep√ß√£o"
        ],
        "responses": [
            "Opa, falha nossa! üòü Isso n√£o √© nada rock'n'roll. Me conta o que rolou pra gente consertar essa distor√ß√£o agora mesmo.",
            "Putz! Pedimos desculpas. Nossa miss√£o √© fazer um show perfeito. Por favor, diga qual foi o problema e vamos resolver na hora.",
            "Que mancada! üòà Sentimos muito por isso. Sua satisfa√ß√£o √© o nosso maior hit. Vamos corrigir isso. O que aconteceu?",
            "Desafina√ß√£o total! üé∏ Isso n√£o condiz com o nosso padr√£o rock. Conta pra gente o que houve que a gente resolve esse problema na velocidade da luz!"
        ]
    },
    
    "hours": {
        "examples": [
            "hor√°rio de funcionamento", "voc√™s abrem hoje", "at√© que horas funciona", "quando fecha",
            "que horas abrem", "aberto agora", "funcionamento", "horarios", "aberto domingo",
            "horario de funcinamento", "voces abrem oje", "ate ke horas funciona", "kuando fecha",
            "ke horas abrem", "abertu agora", "funcionamentu", "horarios", "abertu domingo",
            "que horas abre", "hor√°rio hoje", "funciona que horas", "fecha que horas",
            "aberto segunda", "hor√°rio de hoje", "que dias abrem", "segunda abre"
        ],
        "responses": [
            "O show nunca para! ü§ò Funcionamos de Ter√ßa a Domingo, das 18h at√© a meia-noite (00h). Na Segunda, a gente descansa pra afinar os instrumentos.",
            "Nosso palco abre de Ter√ßa a Domingo! O som come√ßa √†s 18h e s√≥ para √† meia-noite. Delivery vai at√© 23h30.",
            "Hor√°rios do rock: üé∏\n‚Ä¢ Ter√ßa a Domingo: 18h00 - 00h00\n‚Ä¢ Delivery at√©: 23h30\n‚Ä¢ Segunda: Fechado (dia de descanso da banda)",
            "Palco aberto! üéµ\nTer√ßa-feira a Domingo das 18h √†s 00h. Delivery rola at√© 23h30. Segunda √© nosso dia off pra manu√ß√£o dos equipamentos!"
        ]
    },
    
    "fallback": {
        "examples": [
            "n√£o entendi", "o que", "como assim", "???", "hein", "nao entendi", "o ke",
            "como asim", "???", "ein", "que", "oi?", "como", "n√£o sei", "perdao",
            "repete", "n√£o compreendi", "explica", "?", "nao sei", "repeti",
            "nao compreendi", "esplica", "fala dnv", "nao captei"
        ],
        "responses": [
            "Desculpe, essa parte do som ficou meio distorcida. üòµ‚Äçüí´ Posso te ajudar com o card√°pio, pedidos, pre√ßos, hor√°rios ou reclama√ß√µes.",
            "N√£o captei essa mensagem, rockstar. Tente de novo. Quer saber sobre nossos lanches, fazer um pedido ou ver os hor√°rios?",
            "Hmm, acho que perdi essa parte do riff. Pode reformular sua pergunta? Estou aqui pra falar dos nossos burgers lend√°rios!",
            "Som meio embolado a√≠! üé∏ Vamos tentar de novo? Posso te ajudar com menu, pedidos, pre√ßos, delivery, hor√°rios ou resolver algum problema."
        ]
    }
}

# Transformar em dataframe (utterance, intent)
rows = []
for intent, v in intents.items():
    for ex in v["examples"]:
        rows.append({"text": ex, "intent": intent})

df = pd.DataFrame(rows)

# Downloads (apenas na primeira execu√ß√£o) com verifica√ß√µes e fallbacks.
# Tentamos baixar os recursos necess√°rios; se falhar (por exemplo, sem internet),
# o app usa alternativas robustas para n√£o travar em produ√ß√£o.
resource_checks = [
    ('punkt', 'tokenizers/punkt'),
    ('stopwords', 'corpora/stopwords'),
    ('wordnet', 'corpora/wordnet'),
    ('omw-1.4', 'corpora/omw-1.4')
]

have_punkt = False
have_stopwords = False
have_wordnet = False

for name, path in resource_checks:
    try:
        nltk.data.find(path)
        if name == 'punkt':
            have_punkt = True
        if name == 'stopwords':
            have_stopwords = True
        if name in ('wordnet', 'omw-1.4'):
            have_wordnet = True
    except LookupError:
        try:
            # quiet=True evita muita sa√≠da no deploy
            nltk.download(name, quiet=True)
            # Re-check
            nltk.data.find(path)
            if name == 'punkt':
                have_punkt = True
            if name == 'stopwords':
                have_stopwords = True
            if name in ('wordnet', 'omw-1.4'):
                have_wordnet = True
        except Exception:
            # Se n√£o for poss√≠vel baixar, seguimos com fallback
            pass

# Stopwords (fallback vazio / pequeno conjunto se n√£o houver recursos)
if have_stopwords:
    try:
        stop_words = set(stopwords.words('portuguese'))
    except Exception:
        stop_words = set()
else:
    # Um pequeno conjunto de stopwords em portugu√™s como fallback
    stop_words = set([
        'de', 'a', 'o', 'que', 'e', 'do', 'da', 'em', 'um', 'para', '√©', 'com', 'n√£o', 'uma',
        'os', 'no', 'se', 'na', 'por', 'mais', 'as', 'dos', 'como', 'mas', 'foi', 'ao', 'ele'
    ])

# Lemmatizer (s√≥ ser√° usado se wordnet estiver dispon√≠vel)
lemmatizer = None
if have_wordnet:
    try:
        lemmatizer = WordNetLemmatizer()
    except Exception:
        lemmatizer = None


def normalize_text(text):
    text = text.lower()
    text = re.sub(r'[%s]' % re.escape(string.punctuation), ' ', text)
    # Tenta usar o tokenizador do NLTK (punkt). Se n√£o estiver dispon√≠vel,
    # faz um tokenizador simples baseado em regex para evitar crash no deploy.
    try:
        # se punkt n√£o foi encontrado, nltk.word_tokenize lan√ßar√° LookupError
        tokens = nltk.word_tokenize(text)
    except LookupError:
        tokens = re.findall(r"\b[\w']+\b", text, flags=re.UNICODE)
    tokens = [t for t in tokens if t.isalpha()]
    tokens = [t for t in tokens if t not in stop_words]
    # Aplica lematiza√ß√£o apenas se o lemmatizer estiver dispon√≠vel
    if lemmatizer is not None:
        try:
            tokens = [lemmatizer.lemmatize(t) for t in tokens]
        except Exception:
            # Se algo der errado na lematiza√ß√£o, mantemos os tokens originais
            pass
    return ' '.join(tokens)

df['text_norm'] = df['text'].apply(normalize_text)

# Criar vetorizadores
tfidf_vect = TfidfVectorizer()
X_tfidf = tfidf_vect.fit_transform(df['text_norm'])

# Treinar classificador
clf = LogisticRegression(max_iter=1000, random_state=42)
clf.fit(X_tfidf, df['intent'])


def retrieve_response(query, vect=tfidf_vect, utter_vecs=X_tfidf, df=df, threshold=0.6):
    q = normalize_text(query)
    qv = vect.transform([q])
    sims = cosine_similarity(qv, utter_vecs).flatten()
    idx_sorted = np.argsort(-sims)
    if sims[idx_sorted[0]] >= threshold:
        chosen_idx = idx_sorted[0]
        intent = df.iloc[chosen_idx]['intent']
        resp = np.random.choice(intents[intent]['responses'])
        return resp, intent, sims[idx_sorted[0]]
    else:
        return np.random.choice(intents['fallback']['responses']), 'fallback', sims[idx_sorted[0]]

def detect_multiple_intents(query, threshold_clf=0.3, threshold_retrieve=0.3):
    """Detecta m√∫ltiplas inten√ß√µes em uma √∫nica frase"""
    import re
    
    # Primeiro, tenta detectar inten√ß√µes na frase completa
    detected_intents = []
    
    # Verifica greeting no in√≠cio da frase
    greeting_words = ['oi', 'ol√°', 'hello', 'hey', 'e a√≠', 'fala', 'salve', 'bom dia', 'boa tarde', 'boa noite']
    query_lower = query.lower()
    for greeting in greeting_words:
        if query_lower.startswith(greeting) or f' {greeting} ' in query_lower:
            detected_intents.append({
                'intent': 'greeting',
                'confidence': 0.95,
                'method': 'keyword_detection',
                'segment': greeting
            })
            break
    
    # Verifica goodbye no final da frase
    goodbye_words = ['tchau', 'falou', 'bye', 'adeus', 'at√© mais', 'at√© logo', 'valeu tchau', 'xau']
    for goodbye in goodbye_words:
        if query_lower.endswith(goodbye) or f' {goodbye}' in query_lower:
            if not any(d['intent'] == 'goodbye' for d in detected_intents):
                detected_intents.append({
                    'intent': 'goodbye',
                    'confidence': 0.95,
                    'method': 'keyword_detection',
                    'segment': goodbye
                })
            break
    
    # Verifica thanks em qualquer lugar
    thanks_words = ['obrigado', 'obrigada', 'valeu', 'brigado', 'grato', 'agradeco', 'thanks']
    for thanks in thanks_words:
        if thanks in query_lower:
            if not any(d['intent'] == 'thanks' for d in detected_intents):
                detected_intents.append({
                    'intent': 'thanks',
                    'confidence': 0.90,
                    'method': 'keyword_detection',
                    'segment': thanks
                })
            break
    
    # Divide a frase em segmentos para detectar outras inten√ß√µes
    segments = re.split(r'[,.;!?]|\be\b|\stamb√©m\b|\sainda\b|\se\b|\squero\b|\sgostaria\b', query.lower())
    segments = [seg.strip() for seg in segments if seg.strip()]
    
    # Se n√£o h√° segmentos m√∫ltiplos, usa a frase completa
    if len(segments) <= 1:
        segments = [query]
    
    for segment in segments:
        if len(segment.split()) < 2:  # Ignora segmentos muito pequenos
            continue
            
        # Testa classificador
        q_norm = normalize_text(segment)
        if not q_norm:  # Se n√£o h√° texto normalizado, pula
            continue
            
        qv = tfidf_vect.transform([q_norm])
        probs = clf.predict_proba(qv)[0]
        
        # Pega as top 3 inten√ß√µes mais prov√°veis
        top_indices = np.argsort(-probs)[:3]
        
        for idx in top_indices:
            intent = clf.classes_[idx]
            prob = probs[idx]
            
            # Verifica se j√° foi detectada por keyword
            already_detected = any(d['intent'] == intent for d in detected_intents)
            
            if prob >= threshold_clf and not already_detected:
                detected_intents.append({
                    'intent': intent,
                    'confidence': prob,
                    'method': 'classifier',
                    'segment': segment
                })
                break
        
        # Se n√£o encontrou pelo classificador, tenta retrieval
        if not any(d['segment'] == segment for d in detected_intents if d['method'] in ['classifier', 'retrieval']):
            _, intent_ret, sim = retrieve_response(segment, threshold=threshold_retrieve)
            if intent_ret != 'fallback':
                already_detected = any(d['intent'] == intent_ret for d in detected_intents)
                if not already_detected:
                    detected_intents.append({
                        'intent': intent_ret,
                        'confidence': sim,
                        'method': 'retrieval',
                        'segment': segment
                    })
    
    # Se n√£o detectou nada, usa fallback
    if not detected_intents:
        detected_intents.append({
            'intent': 'fallback',
            'confidence': 0.0,
            'method': 'fallback',
            'segment': query
        })
    
    # Ordena por confian√ßa (maior primeiro)
    detected_intents.sort(key=lambda x: x['confidence'], reverse=True)
    
    return detected_intents

def generate_multi_intent_response(detected_intents):
    """Gera resposta baseada em m√∫ltiplas inten√ß√µes detectadas"""
    if len(detected_intents) == 1:
        intent_data = detected_intents[0]
        resp = np.random.choice(intents[intent_data['intent']]['responses'])
        return resp, intent_data
    
    # Para m√∫ltiplas inten√ß√µes, cria uma resposta combinada
    response_parts = []
    primary_intent = detected_intents[0]  # A primeira ser√° considerada principal
    
    for intent_data in detected_intents:
        intent = intent_data['intent']
        if intent == 'greeting':
            response_parts.append("Salve, rockstar! ü§ò")
        elif intent == 'menu':
            response_parts.append("Aqui est√° nosso setlist:\n‚Ä¢ Master of Burgers (R$ 35)\n‚Ä¢ Appetite for Destruction (R$ 38)\n‚Ä¢ Highway to Hell (R$ 33)\n‚Ä¢ The Trooper (R$ 36)\n‚Ä¢ Paranoid (R$ 34)\n‚Ä¢ Stairway to Heaven (R$ 40)\n‚Ä¢ Ace of Spades Vegano (R$ 32)")
        elif intent == 'prices':
            response_parts.append("Nossos pre√ßos v√£o de R$ 32 (Ace of Spades) at√© R$ 40 (Stairway to Heaven).")
        elif intent == 'purchase':
            response_parts.append("Qual burger vai ser? Todos s√£o hits garantidos!")
        elif intent == 'delivery_time':
            response_parts.append("Preparo: 15-20 min + Delivery: 20-30 min.")
        elif intent == 'hours':
            response_parts.append("Funcionamos Ter√ßa a Domingo, 18h √†s 00h.")
        elif intent == 'thanks':
            response_parts.append("Valeu! ü§ò")
        elif intent == 'goodbye':
            response_parts.append("At√© a pr√≥xima! Keep rockin'!")
    
    combined_response = "\n\n".join(response_parts)
    
    if not combined_response:
        combined_response = np.random.choice(intents['fallback']['responses'])
    
    return combined_response, primary_intent

def combined_respond(query, threshold_clf=0.6, threshold_retrieve=0.4):
    # Detecta m√∫ltiplas inten√ß√µes
    detected_intents = detect_multiple_intents(query, threshold_clf * 0.5, threshold_retrieve)
    
    # Gera resposta baseada nas inten√ß√µes detectadas
    response, primary_intent = generate_multi_intent_response(detected_intents)
    
    return response, detected_intents, primary_intent

# Interface do Streamlit
st.title('üíÄ Chatbot RockStar Burger ü§ò')

# Sidebar com informa√ß√µes
# NOTA: A API do Streamlit posiciona a sidebar sempre √† esquerda.
st.sidebar.markdown("""
### ‚úùÔ∏è Funcionalidades do Palco ‚úùÔ∏è
- **Inten√ß√µes suportadas:**
  - üòá Cumprimentos e Despedidas
  - üõí Pedidos de Burgers
  - üêç Card√°pio e Pre√ßos
  - üê∫ Hor√°rios de Funcionamento
  - ü¶á Tempo de Entrega
  - ‚òÆÔ∏è Agradecimentos
  - üòà Reclama√ß√µes
  
- **Tecnologias:**
  - TF-IDF Vectorization
  - Logistic Regression Classifier
  - Cosine Similarity Retrieval
""")

# Configura√ß√µes avan√ßadas
st.sidebar.markdown("### ‚öôÔ∏è Ajuste o Som")
mode = st.sidebar.selectbox(
    'Modo de Opera√ß√£o:',  
    ['üîÑ H√≠brido (Recomendado)', 'üéØ Apenas Classificador', 'üîç Apenas Retrieval'],
    help="Escolha como o chatbot deve processar as mensagens"
)

# Sliders de confian√ßa na vertical
st.sidebar.markdown("### üéöÔ∏è N√≠veis de Confian√ßa")
if mode == 'üîÑ H√≠brido (Recomendado)':
    threshold_clf = st.sidebar.slider('Confian√ßa Classificador üß†', 0.0, 1.0, 0.6, 0.05)
    threshold_ret = st.sidebar.slider('Confian√ßa Similaridade üîç', 0.0, 1.0, 0.4, 0.05)
elif mode == 'üéØ Apenas Classificador':
    threshold_clf = st.sidebar.slider('Confian√ßa Classificador üß†', 0.0, 1.0, 0.5, 0.05)
    threshold_ret = 0.0
else:  # Retrieval only
    threshold_clf = 1.0
    threshold_ret = st.sidebar.slider('Confian√ßa Similaridade üîç', 0.0, 1.0, 0.6, 0.05)

# Input do usu√°rio
st.markdown("### üí¨ Mande seu recado para a banda")

user_input = st.text_area(
    "Digite sua mensagem:",  
    height=100,
    placeholder="Ex: E a√≠! Quero um Master of Burgers. Quanto tempo demora?"
)

# Bot√£o de envio
if st.button("üé∏ Enviar Mensagem", type="primary"):
    if user_input:
        with st.spinner('Afinando os instrumentos... üé∏'):
            if mode == 'üîÑ H√≠brido (Recomendado)':
                response, detected_intents, primary_intent = combined_respond(user_input, threshold_clf, threshold_ret)
            elif mode == 'üéØ Apenas Classificador':
                response, detected_intents, primary_intent = combined_respond(user_input, threshold_clf, 0.0)
            else:  # Retrieval only
                resp, intent, confidence = retrieve_response(user_input, threshold=threshold_ret)
                source = 'retrieval' if intent != 'fallback' else 'fallback'
                # Converte para o novo formato
                detected_intents = [{
                    'intent': intent,
                    'confidence': confidence,
                    'method': source,
                    'segment': user_input
                }]
                primary_intent = detected_intents[0]
                response = resp
        
        # Exibi√ß√£o dos resultados
        st.markdown("---")
        
        col1, col2 = st.columns([1, 2])
        with col1:
            st.markdown("**üë§ Voc√™ disse:**")
        with col2:
            st.info(user_input)
            
        st.markdown("**ü§ñ RockStar Burger responde:**")
        st.markdown(f'<div class="chatbot-response">{response}</div>', unsafe_allow_html=True)
        
        # An√°lise t√©cnica
        st.markdown("### üìä Backstage (An√°lise T√©cnica)")
        
        # Mostra todas as inten√ß√µes detectadas
        st.markdown("**üéØ Inten√ß√µes Detectadas:**")
        
        if len(detected_intents) == 1:
            # Uma √∫nica inten√ß√£o
            intent_data = detected_intents[0]
            intent_display = intent_data['intent'].replace('_', ' ').title()
            confidence_pct = intent_data['confidence'] * 100
            confidence_color = "üü¢" if confidence_pct >= 70 else "üü°" if confidence_pct >= 50 else "üî¥"
            
            col1, col2 = st.columns(2)
            with col1:
                st.success(f"**{intent_display}**")
                st.info(f"**{confidence_color} {confidence_pct:.1f}%**")
            
            with col2:
                source_emoji = {
                    'classifier': 'üß† Classificador ML',
                    'retrieval': 'üîç Busca por Similaridade',
                    'fallback': '‚ùì Resposta Padr√£o'
                }
                method_name = source_emoji.get(intent_data['method'], intent_data['method'])
                st.warning(f"**{method_name}**")
        else:
            # M√∫ltiplas inten√ß√µes
            st.info(f"**üîç {len(detected_intents)} inten√ß√µes detectadas na sua mensagem:**")
            
            for i, intent_data in enumerate(detected_intents, 1):
                intent_display = intent_data['intent'].replace('_', ' ').title()
                confidence_pct = intent_data['confidence'] * 100
                confidence_color = "üü¢" if confidence_pct >= 70 else "üü°" if confidence_pct >= 50 else "üî¥"
                
                method_emoji = {
                    'classifier': 'üß†',
                    'retrieval': 'üîç',
                    'fallback': '‚ùì'
                }
                
                with st.expander(f"{i}. {intent_display} {confidence_color} {confidence_pct:.1f}%"):
                    st.write(f"**Segmento analisado:** '{intent_data['segment']}'")
                    st.write(f"**M√©todo:** {method_emoji.get(intent_data['method'], '')} {intent_data['method'].title()}")
                    st.write(f"**Confian√ßa:** {confidence_pct:.1f}%")
        
        # Texto normalizado
        st.markdown("### üî§ Processamento de Texto")
        normalized = normalize_text(user_input)
        
        col1, col2 = st.columns(2)
        with col1:
            st.markdown("**üìù Texto Original:**")
            st.code(user_input, language="text")
        with col2:
            st.markdown("**üî§ Texto Normalizado:**")
            st.code(normalized, language="text")

# Rodap√©
st.markdown("---")
st.markdown("""
<div style='text-align: center; font-family: "Courier New", monospace; color: #CCCCCC;'>
    <small>
    ü§ò <strong>RockStar Burger</strong> - O sabor do rock na sua fome ü§ò<br>
    Chatbot desenvolvido com Python, Streamlit & N.L.P.
    </small>
</div>
""", unsafe_allow_html=True)